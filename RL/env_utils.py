import math
import numpy as np

# Helper functions

def get_vehicle_speed_accel(vehicle):

    """Returns vehicle speed (m/s) and acceleration (m/s²)."""
    vel = vehicle.get_velocity()
    speed = math.sqrt(vel.x**2 + vel.y**2 + vel.z**2)

    accel = vehicle.get_acceleration()
    acceleration = math.sqrt(accel.x**2 + accel.y**2 + accel.z**2)

    return speed, acceleration

def get_ego_transform(vehicle):
    """Returns ego vehicle position and yaw angle in radians."""
    transform = vehicle.get_transform()
    loc = transform.location
    yaw = math.radians(transform.rotation.yaw)
    return np.array([loc.x, loc.y, loc.z]), yaw

def global_to_local(ego_pos, ego_yaw, waypoint_pos):
    """Transforms a waypoint from global to ego-local coordinates."""
    dx = waypoint_pos[0] - ego_pos[0]
    dy = waypoint_pos[1] - ego_pos[1]
    x_local = np.cos(-ego_yaw) * dx - np.sin(-ego_yaw) * dy
    y_local = np.sin(-ego_yaw) * dx + np.cos(-ego_yaw) * dy
    return np.array([x_local, y_local])

def build_state_vector(vehicle, waypoints, frame_size, lane_width, speed, accel, steering, dist_to_obj_ahead):
    """
    Builds the state vector (observation) for the DRL agent, prioritizing polar coordinates
    (distance, angle) and proprioceptive feedback (current steering).

    Args:
        vehicle: CARLA vehicle actor (used to get current steering command)
        waypoints: list of CARLA waypoints (the global path generated by the agent)
        frame_size: int, number of future waypoints to include (e.g., 14)
        lane_width: float, width of the lane for normalization (e.g., 3.5)
        speed: float, current speed of the vehicle (m/s)
        accel: float, current acceleration of the vehicle (m/s²)
        steering: float, current steering command applied by the agent [-1, 1]
        dist_to_obj_ahead: float, distance to car ahead (m)

    Returns:
        np.ndarray of shape (2 * frame_size + 5,), the normalized state vector.
    """
    ego_pos, ego_yaw = get_ego_transform(vehicle)

    # --- CONSTANTS ---
    MAX_LOOKAHEAD_DIST = 50.0  # Max physical range for waypoints (m)
    MAX_REF_LATERAL = lane_width / 2.0  # Max lateral offset for normalization (m)
    REF_SPEED = 15.0  # Reference speed for normalization (~54 km/h)
    REF_ACCEL = 10.0  # Reference acceleration (m/s²)

    # --- 1. Waypoint Filtering & Transformation (Polar) ---

    polar_coords = []
    future_local_coords = []

    # First, transform all relevant waypoints and filter out stale/behind points
    for wp in waypoints:
        local_coords = global_to_local(
            ego_pos, ego_yaw, (wp.transform.location.x, wp.transform.location.y)
        )

        # Filter: Only accept waypoints that are not significantly behind the vehicle center
        # This prevents the network from being confused by stale points.
        # if local_coords[0] > -1.0:
        #     future_local_coords.append(local_coords)


    # Now, convert filtered points to Polar Coordinates and normalize
    for lx, ly in future_local_coords:
        # Distance (r)
        dist = np.sqrt(lx ** 2 + ly ** 2)

        # Angle (theta) - The primary steering error signal
        angle_rad = np.arctan2(ly, lx)

        # Normalize Angle by the maximum useful angle (+/- 90 degrees or pi/2)
        angle_norm = np.clip(angle_rad / (np.pi / 2), -1, 1)

        # Normalize Distance by max lookahead range
        dist_norm = np.clip(dist / MAX_LOOKAHEAD_DIST, 0, 1)

        polar_coords.extend([dist_norm, angle_norm])

    # Padding: Fill the rest of the vector with the "Far, Straight Ahead" signal
    while len(polar_coords) < frame_size * 2:
        polar_coords.extend([1.0, 0.0])

    # --- 2. Proprioceptive & Safety Features ---

    # Dynamics
    speed_norm = np.clip(speed / REF_SPEED, 0, 1)
    accel_norm = np.clip(accel / REF_ACCEL, -1, 1)

    # Proprioception: Get the current wheel command being applied by the agent
    # This is CRITICAL for smooth, stable control.
    steering_norm = np.clip(steering, -1, 1)

    # Lane Centering (Cross-Track Error - CTE)
    # Use the Y component of the immediate *first valid* waypoint (polar_coords[1] is the angle)
    # Since we need the lateral distance (Y), we use the raw Y from the first filtered point.
    if len(future_local_coords) > 0:
        cte_norm = np.clip(future_local_coords[0][1] / MAX_REF_LATERAL, -1, 1)
    else:
        cte_norm = 0.0

    # Safety
    dist_norm = np.clip(dist_to_obj_ahead / MAX_LOOKAHEAD_DIST, 0, 1)

    # --- 3. Final Vector Assembly ---
    final_state = np.concatenate([
        np.array(polar_coords, dtype=np.float32),  # Path Geometry (Angle/Distance)
        np.array([speed_norm], dtype=np.float32),  # Dynamics
        np.array([accel_norm], dtype=np.float32),  # Acceleration
        np.array([steering_norm], dtype=np.float32),  # Current Control Command (Proprioception)
        np.array([cte_norm], dtype=np.float32),  # Immediate Lateral Error (Lane Centering)
        np.array([dist_norm], dtype=np.float32)  # Radar Distance
    ])

    return final_state